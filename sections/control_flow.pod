=encoding utf8

=head1 控制流程 

Z<control_flow>

X<control flow>

Perl 的基本 I<控制流程> 相当直截了当。程序执行过程起始于程序开头（被执行文件的第一行）
然后一直到结尾：

=begin programlisting

    say 'At start';
    say 'In middle';
    say 'At end';

=end programlisting

X<control flow directives>

大多数程序需要更为复杂的控制流程。Perl 的 I<控制流程语句> 改变了程序执行的顺序────程序
中接下来要发生的────依赖于任意复杂的表达式的值。

=head2 分支语句

X<if>
X<control flow directives; if>
X<postfix if>
X<postfix expressions; if>

C<if> 语句对一条件表达式求值并仅在此条件表达式的值为真时执行相关动作：

=begin programlisting

    say 'Hello, Bob!' if $name eq 'Bob';

=end programlisting

这种后缀形式在表达式较简单时很有用。代码块形式则将多个表达式组合成单一单元：

=begin programlisting

    if ($name eq 'Bob')
    {
        say 'Hello, Bob!';
        found_bob();
    }

=end programlisting

虽然代码块形式要求条件两边有括号，但后缀形式则相反。条件表达式也可以相对复杂：

=begin programlisting

    if ($name eq 'Bob' && not greeted_bob())
    {
        say 'Hello, Bob!';
        found_bob();
    }

=end programlisting

……虽然在此种情况下，采用后缀形式的括号形式可以使其稍显清晰
N<同时也会因此对是否使用后缀形式产生争论>：

=begin programlisting

    greet_bob() if ($name eq 'Bob' && not greeted_bob());

=end programlisting

X<unless>
X<control flow directives; unless>
X<postfix unless>
X<postfix expressions; unless>

C<unless> 语句是 C<if> 的否定形式。Perl 在条件表达式的值为 I<假> 时执行
所需操作：

=begin programlisting

    say "You're no Bob!" unless $name eq 'Bob';

=end programlisting

和 C<if> 类似，C<unless> 也有代码块形式。不同于 C<if>，C<unless> 的代码块形式相比其 
后缀形式来说很少见：

=begin programlisting

    unless (is_leap_year() and is_full_moon())
    {
        frolic();
        gambol();
    }

=end programlisting

C<unless> 很适合后缀条件，特别是函数中的参数验证（L<postfix_parameter_validation>）：

=begin programlisting

    sub frolic
    {
        return unless @_;

        for my $chant (@_)
        {
            ...
        }
    }

=end programlisting

条件一多 C<unless> 就会变得难以阅读，这便是它很少以代码块形式出现的原因之一。

X<else>
X<control flow directives; else>

C<if> 以及 C<unless> 都可以搭配 C<else> 语句，它提供了当条件表达式的值不为真（C<if>）
或假（C<unless>）时运行的代码：

=begin programlisting

    if ($name eq 'Bob')
    {
        say 'Hi, Bob!';
        greet_user();
    }
    else
    {
        say "I don't know you.";
        shun_user();
    }

=end programlisting

C<else> 代码块允许你按不同于自身的方式重写 C<if> 和 C<unless> 条件语句：

=begin programlisting

    B<unless> ($name eq 'Bob')
    {
        say "I don't know you.";
        shun_user();
    }
    else
    {
        say 'Hi, Bob!';
        greet_user();
    }

=end programlisting

如果你大声读出前面这个例子，你会发现一例不合适的伪代码用词：“除非该名字为 Bob，做这件事。否则
做那件。”隐含的双重否定可能会很迷惑。Perl 提供了 C<if> 和 C<unless> 使得你可以按最为自然、
最为上口的方式对条件语句进行组织。同样地，你可以根据比较操作符在肯定和否定断言之间进行选择：

=begin programlisting

    if ($name B<ne> 'Bob')
    {
        say "I don't know you.";
        shun_user();
    }
    else
    {
        say 'Hi, Bob!';
        greet_user();
    }

=end programlisting

因 C<else> 代码块的出现而隐含着的双重否定示意此代码组织方式是不合理的。

X<elsif>
X<control flow directives; elsif>

在单个 C<else> 之前、C<if> 代码块之后可以跟一个或多个 C<elsif> 语句。C<elsif> 代码块的使用数量不限，
但你不可以改变块出现的顺序：

=begin programlisting

    if ($name eq 'Bob')
    {
        say 'Hi, Bob!';
        greet_user();
    }
    elsif ($name eq 'Jim')
    {
        say 'Hi, Jim!';
        greet_user();
    }
    else
    {
        say "You're not my uncle.";
        shun_user();
    }

=end programlisting

你也可以在 C<unless> 链内使用 C<elsif> 块，但是结果代码会不那么清晰。不存在 C<elseunless> 的说法。

同样也没有 C<else if> 这一语法结构 N<Larry 出于美学原因以及 Ada 编程语言的现有技术选择了 C<elsif>>，
因此，这段代码含有语法错误：

=begin programlisting

    if ($name eq 'Rick')
    {
        say 'Hi, cousin!';
    }

    # warning; syntax error
    else if ($name eq 'Kristen')
    {
        say 'Hi, cousin-in-law!';
    }

=end programlisting

=head2 三元条件操作符

X<ternary conditional>
X<control flow directives; ternary conditional>

I<三元条件> 操作符提供了另一种方法来控制流程。它先将条件表达式求值，并由此对两不同结果之一求值：

=begin programlisting

    my $time_suffix = after_noon($time) ? 'morning' : 'afternoon';

=end programlisting

条件表达式位于问号（C<?>）之前，冒号（C<:>）分隔两种选择。这两个选择分支可以是字面值或者（带括号）
任意复杂的表达式，包括其他的三元条件表达式（以可读性为代价）。

=begin sidebar

一个有趣但晦涩的惯用语便是使用三元条件语句在两个候选 I<变量> 之间做出选择，而非仅仅对值：

=begin programlisting

    push @{ rand() > 0.5 ? \@red_team : \@blue_team }, Player->new();

=end programlisting

再次提醒，请对清晰和简略各自带来的利益进行权衡。

=end sidebar

=head3 短路求值

X<short circuiting behavior>
X<short circuiting>

当遇到由多重待求值的表达式组成的复杂表达式时，Perl 将做出名为 I<短路求值> 的行为。如果 Perl
可以决定一个复杂的表达式整体的值是真还是假，那么它不会对后续子表达式求值。用例子说明会更加明白：

=begin programlisting

    # see preface
    use Test::More 'no_plan';

    say "Both true!" if ok(1, 'first subexpression')
                     && ok(1, 'second subexpression');

    done_testing();

=end programlisting

=begin sidebar

C<ok()> 的返回值（L<testing>）是对第一个参数求值得到的。

=end sidebar

这个例子打印出：

=begin screen

    ok 1 - first subexpression
    ok 2 - second subexpression
    Both true!

=end screen

当第一个子表达式────对 C<ok> 的第一次调用────求得真值时，Perl 必须对第二个字表达式求值。
当第一个表达式求得假值时，整个表达式不为真，因此无需检查后续子表达式。

=begin programlisting

    say "Both true!" if ok(0, 'first subexpression')
                     && ok(1, 'second subexpression');

=end programlisting

这个例子打印出：

=begin screen

    not ok 1 - first subexpression

=end screen

虽然第二个子表达式显然为真，Perl 绝不对其求值。对于“一真即真”复杂条件表达式来说，
其逻辑也是相似的：

=begin programlisting

    say "Either true!" if ok(1, 'first subexpression')
                       || ok(1, 'second subexpression');

=end programlisting

这个例子打印出：

=begin screen

    ok 1 - first subexpression
    Either true!

=end screen

再次，第一个子表达式为真，Perl 可以避免对第二个子表达式求值。如果第一个子表达式为假，
则对第二个子表达式求值的结果将决定整个表达式的真假。

除了可以让你避免潜在的昂贵计算，短路求值还可以帮助你避免错误和警告：

=begin programlisting

    if (exists $barbeque{pork} and $barbeque{pork} eq 'shoulder') { ... }

=end programlisting


=head2 条件语句相关的上下文

X<context; conditional>
X<truth>
X<boolean truth>
X<true value>
X<false value>

这些条件语句────C<if>、C<unless>，以及三元条件表达式────总是在布尔上下文（L<context_philosophy>）
中对一个表达式进行求值。由于 C<eq>、C<==>、C<ne> 和 C<!=> 这类操作符在求值时总产生布尔结果，Perl
将其他表达式的求值结果────包括变量和值────强制转换为布尔形式。对空哈希和数组求值得假。

Perl 5 没有单一的真值、也没有单一的假值。任何求值为 0 的数字为假。包括 C<0>、C<0.0>、C<0e0>、
C<0x0> 等等。空字符串（C<''>）以及 C<"0"> 求值得假，但是字符串如 C<"0.0">、C<"0e0"> 等则不然。
惯用语 C<"0 but true"> 在数值上下文中求值得 0，但其值因字符串内容而为真。空列表和 C<undef> 都
为假。空数组和哈希在标量上下文中返回 0，因此它们在布尔上下文中为假。

带有单个元素的数组────即便该元素是 C<undef>────在布尔上下文中求值得真，含任何元素的哈希────
即使是一键一值两个 C<undef>────在布尔上下文中也得真。

=begin sidebar

CPAN 模块 C<Want> 允许你在你的函数内检测布尔上下文。核心编译命令 C<overloading>（L<overloading>、
L<pragmas>）允许你指定自己的数据类型在布尔上下文中求得的值。

=end sidebar

=head2 循环语句

Z<looping_directives>

Perl 也提供了供循环和迭代使用的若干语句。

X<foreach>
X<for>
X<looping directives; for>
X<looping directives; foreach>

I<foreach> 风格的循环对一表达式求值而产生一个列表，接着执行某语句或代码块直到它消耗完该列表：

=begin programlisting

    foreach (1 .. 10)
    {
        say "$_ * $_ = ", $_ * $_;
    }

=end programlisting

这个例子使用范围操作符产生了一个包括一到十在内的整数列表。C<foreach> 语句在其之上循环，依次设置话题变量
（C<$_>，参见 L<default_scalar_variable>）。Perl 针对每个整数执行代码块并打印该整数的平方。

=begin sidebar

Perl 将 C<foreach> 和 C<for> 可互换地看待。循环余下部分的语句决定了循环的行为。尽管有经验的 Perl 程序员
倾向于用 C<foreach> 循环来指代自动迭代循环，你可以在任何用到 C<foreach> 的地方安全地用 C<for> 替代。

=end sidebar

如同 C<if> 及 C<unless>，C<for> 循环也有一个后缀形式：

=begin programlisting

    say "$_ * $_ = ", $_ * $_ for 1 .. 10;

=end programlisting

有关清晰、简略的建议同样适用于此。

你可以提供一个用于赋值变量以代替话题变量：

=begin programlisting

    for my $i (1 .. 10)
    {
        say "$i * $i = ", $i * $i;
    }

=end programlisting

如果你这样做了，Perl 将不会将话题变量（C<$_>）赋值为迭代值。注意变量 C<$i> 的作用域仅限于循环 I<内部>。
如果你在循环外定义了词法变量 C<$i>，它的值将不受循环内变量的影响：

=begin programlisting

    my $i = 'cow';

    for my $i (1 .. 10)
    {
        say "$i * $i = ", $i * $i;
    }

    is( $i, 'cow', 'Lexical variable not overwritten in outer scope' );

=end programlisting

甚至你不将该迭代变量重新声明为词法变量，它仍会被局部化：

=begin programlisting

    my $i = 'horse';

    for $i (1 .. 10)
    {
        say "$i * $i = ", $i * $i;
    }

    is( $i, 'horse', 'Lexical variable still not overwritten in outer scope' );

=end programlisting

=head2 迭代和别名

X<iteration aliasing>
X<aliasing>
X<aliasing; foreach>
X<aliasing; iteration>

C<for> 循环将迭代变量 I<别名化> 为迭代中的值，以便你可以直接在迭代过程中修改：

=begin programlisting

    my @nums = 1 .. 10;

    $_ **= 2 for @nums;

    is( $nums[0], 1, '1 * 1 is 1' );
    is( $nums[1], 4, '2 * 2 is 4' );

    ...

    is( $nums[9], 100, '10 * 10 is 100' );

=end programlisting

代码块形式的 C<foreach> 循环同样也会别名化：

=begin programlisting

    for my $num (@nums)
    {
        $num **= 2;
    }

=end programlisting

……用话题变量迭代时也会：

=begin programlisting

    for (@nums)
    {
        $_ **= 2;
    }

=end programlisting

你不能通过别名修改 I<常量> 值，然而：

=begin programlisting

    for (qw( Huex Dewex Louie ))
    {
        $_++;
        say;
    }

=end programlisting

……会抛出有关修改只读值的异常。无论如何，这样并没有什么必要。

你偶尔会碰到 C<for> 搭配别名化为 C<$_> 的单个标量的用法：

=begin programlisting

    for ($user_input)
    {
        s/(\w)/\\$1/g;  # 跳过非文字字符
        s/^\s*|\s$/g;   # 修剪空白
    }

=end programlisting

=head2 迭代和作用范围

X<iterator scoping>
X<scope; iterator>
X<my $_>
X<$_; lexical>

迭代器的作用范围连同话题变量一起是为常见的困惑之源。这种情况下，C<some_function()> 有意修改 C<$_>。如果
C<some_function()> 调用了其他未经明确局部化 C<$_> 而对其加以修改的代码，则在 C<@values> 中的迭代值将改变。
调试这样的问题很麻烦：

=begin programlisting

    for (@values)
    {
        some_function();
    }

    sub some_function
    {
        s/foo/bar/;
    }

=end programlisting

如果你 I<必须> 使用 C<$_> 而非其他具名变量，请使用 C<my $_> 将话题变量词法化：

=begin programlisting

    sub some_function_called_later
    {
        # 曾经是 $_ = shift;
        B<my> $_ = shift;

        s/foo/bar/;
        s/baz/quux/;

        return $_;
    }

=end programlisting

使用具名变量同时也避免了通过 C<$_> 别名化的行为。

=head2 C 语言风格的 For 循环

X<for loop>

C 语言风格的 I<for 循环> 允许程序员手动控制迭代：

=begin programlisting

    for (my $i = 0; $i <= 10; $i += 2)
    {
        say "$i * $i = ", $i * $i;
    }

=end programlisting

你必须手动给迭代变量赋值，因为现在已经不会自动给话题变量赋值。因此也没有别名化行为。虽然任何
已声明的词法变量的作用范围是代码块主体部分。一个 I<未> 在迭代控制部分中明确声明的变量的内容
I<将> 被覆盖：

=begin programlisting

    my $i = 'pig';

    for ($i = 0; $i <= 10; $i += 2)
    {
        say "$i * $i = ", $i * $i;
    }

    isnt( $i, 'pig', '$i overwritten with a number' );

=end programlisting

此循环的循环结构中有三个子表达式。第一个子表达式是初始化部分，它在第一次执行循环体前执行一
次。第二个子表达式是条件比较子表达式。Perl 每次在循环体执行之前对其求值。当此子表达式值为真时
循环继续。当此子表达式为假时，循环结束。最后一个子表达式在每次完成循环体时执行。

一个例子会使问题更加清晰：

=begin programlisting

    # 在外部声明以避免在条件语句中出现声明
    my $i;

    for (
        # 循环初始化子表达式
        say 'Initializing' and $i = 0;

        # 条件比较子表达式
        say "Iteration: $i" and $i < 10;

        # 迭代结尾子表达式
        say 'Incrementing $i' and $i++
    )
    {
        say "$i * $i = ", $i * $i;
    }

=end programlisting

请注意迭代结尾子表达式后分号的省略以及低优先级 C<and> 的使用。这种语法真是令人惊讶地考究。当可能时，
尽量使用 C<foreach> 风格的循环来代替 C<for> 循环。

所有这个三个表达式都是可选的。你可以这样编写无限循环：

=begin programlisting

    for (;;) { ... }

=end programlisting

=head2 While 和 Until

X<while loop>
X<loops; while>

I<while> 循环会一直执行直到循环条件得出布尔假值。一个无限循环可以按如下方式清晰地写出：

=begin programlisting

    while (1) { ... }

=end programlisting

这意味着 C<while> 循环的迭代结束条件和 C<foreach> 循环中的有所不同，即对表达式自身求值并不产生任何
副作用。如果 C<@values> 拥有一个或多个元素，下列代码也是一个无限循环：

=begin programlisting

    while (@values)
    {
        say $values[0];
    }

=end programlisting

X<destructive update>

为避免此类无限 C<while> 循环，你必须通过每次迭代修改 C<@values> 数组以对其进行 I<析构更新>：

=begin programlisting

    while (my $value = shift @values)
    {
        say $value;
    }

=end programlisting

X<until loop>
X<loops; until>

I<until> 循环刚好和 C<while> 进行相反的测试。迭代会在循环条件表达式为假时继续：

=begin programlisting

    until ($finished_running)
    {
        ...
    }

=end programlisting

C<while> 循环的典型用法是从一个文件句柄中迭代读取输入：

=begin programlisting

    use autodie;

    open my $fh, '<', $file;

    while (<$fh>)
    {
        ...
    }

=end programlisting

Perl 5 对此 C<while> 循环进行解释时，就好像你编写了如下代码：

=begin programlisting

    while (defined($_ = <$fh>))
    {
        ...
    }

=end programlisting

不用明确写出 C<defined>，任何从该文件句柄读出、且求值得假────空行或只包含字符 C<0>────的行会结束整个循
环。当完成从文件中读取行的任务后，C<readline>（C<< <> >>）操作符才返回一个未定义的值。

=begin sidebar

一个常见的错误就是忘记从读入的每一行移除行结束符，使用 C<chomp> 关键字可以完成这项工作。

=end sidebar

C<while> 和 C<until> 都可以写成后缀形式。Perl 5 中最简单的无限循环是：

=begin programlisting

    1 while 1;

=end programlisting

任何单个表达式对后缀式的 C<while> 和 C<until> 来说都是合适的，例如来自八十年代早期 8 位计算机的
经典 "Hello, world!"：

=begin programlisting

    print "Hello, world!  " while 1;

=end programlisting

无限循环可能看上去有点笨拙，但它们实际上很有用。一个简单的 GUI 程序或网络服务器事件循环可以是：

=begin programlisting

    $server->dispatch_results() until $should_shutdown;

=end programlisting

X<do; looping>
X<looping; do>

对于更加复杂的表达式，使用 C<do> 代码块：

=begin programlisting

    do
    {
        say 'What is your name?';
        my $name = <>;
        chomp $name;
        say "Hello, $name!" if $name;
    } until (eof);

=end programlisting

出于语法分析的目的，虽然可以包含若干表达式，C<do> 代码块本身却是一个单一的表达式。不像 C<while> 循环
的代码块形式，搭配后缀式 C<while> 或 C<until> 的 C<do> 代码块至少会执行它的主体一次。这个结构相比其他
循环形式来说较为少见，但在功能上毫不逊色。

=head2 Loops within Loops

X<nested loops>
X<loops; nested>

You may nest loops within other loops:

=begin programlisting

    for my $suit (@suits)
    {
        for my $values (@card_values)
        {
            ...
        }
    }

=end programlisting

In this case, explicitly declaring named variables is essential to
maintainability.  The potential for confusion as to the scoping of iterator
variables is too great when using the topic variable.

A common mistake with nesting C<foreach> and C<while> loops is that it is easy
to exhaust a filehandle with a C<while> loop:

=begin programlisting

    use autodie;

    open my $fh, '<', $some_file;

    for my $prefix (@prefixes)
    {
        # DO NOT USE; likely buggy code
        while (<$fh>)
        {
            say $prefix, $_;
        }
    }

=end programlisting

Opening the filehandle outside of the C<for> loop leaves the file position
unchanged between each iteration of the C<for> loop.  On its second iteration,
the C<while> loop will have nothing to read and will not execute.  To solve
this problem, you may re-open the file inside the C<for> loop (simple to
understand, but not always a good use of system resources), slurp the entire
file into memory (which may not work if the file is large), or C<seek> the
filehandle back to the beginning of the file for each iteration (an often
overlooked option):

=begin programlisting

    use autodie;

    open my $fh, '<', $some_file;

    for my $prefix (@prefixes)
    {
        while (<$fh>)
        {
            say $prefix, $_;
        }

        seek $fh, 0, 0;
    }

=end programlisting

=head2 Loop Control

X<loop control>

Sometimes you need to break out of a loop before you have exhausted the
iteration conditions.  Perl 5's standard control mechanisms--exceptions and
C<return>--work, but you may also use I<loop control> statements.

X<next>

The I<next> statement restarts the loop at its next iteration.  Use it when
you've done all you need to in the current iteration.  To loop over lines in a
file but skip everything that looks like a comment, one which starts with the
character C<#>, you might write:

=begin programlisting

    while (<$fh>)
    {
        B<next> if /\A#/;
        ...
    }

=end programlisting

X<last>

The I<last> statement ends the loop immediately.  To finish processing a file
once you've seen the ending delimiter, you might write:

=begin programlisting

    while (<$fh>)
    {
        next if /\A#/;
        B<last> if /\A__END__/
        ...
    }

=end programlisting

X<redo>

The I<redo> statement restarts the current iteration without evaluating the
conditional again.  This can be useful in those few cases where you want to
modify the line you've read in place, then start processing over from the
beginning without clobbering it with another line.  For example, you could
implement a silly file parser that joins lines which end with a backslash with:

=begin programlisting

    while (my $line = <$fh>)
    {
        chomp $line;

        # match backslash at the end of a line
        if ($line =~ s{\\$}{})
        {
            $line .= <$fh>;
            redo;
        }

        ...
    }

=end programlisting

... though that's a contrived example.

X<labels>
X<loops; labels>

Nested loops can make the use of these loop control statements ambiguous.  In
those cases, a I<loop label> can disambiguate:

=begin programlisting

    OUTER:
    while (<$fh>)
    {
        chomp;

        INNER:
        for my $prefix (@prefixes)
        {
            next OUTER unless $prefix;
            say "$prefix: $_";
        }
    }

=end programlisting

If you find yourself nesting loops such that you need labels to manage control
flow, consider simplifying your code: perhaps extracting inner loops into
functions for clarity.

=head2 Continue

X<continue>

The C<continue> construct behaves like the third subexpression of a C<for>
loop; Perl executes its block for each iteration of the loop, even when you
exit an iteration with C<next>.  You may use it with a C<while>, C<until>,
C<with>, or C<for> loop.  Examples of C<continue> are rare, but it's useful any
time you want to guarantee that something occurs for every iteration of the loop
regardless of how that iteration ends:

=begin programlisting

    while ($i < 10 )
    {
        next unless $i % 2;
        say $i;
    }
    continue
    {
        say 'Continuing...';
        $i++;
    }

=end programlisting

=head2 Given/When

Z<given_when>

X<given>

The C<given> construct is a feature new to Perl 5.10.  It assigns the value of
an expression to the topic variable and introduces a block:

=begin programlisting

    given ($name)
    {
        ...
    }

=end programlisting

Unlike C<for>, it does not iterate over an aggregate.  It evaluates its value
in scalar context, and always assigns to the topic variable:

=begin programlisting

    given (my $username = find_user())
    {
        is( $username, $_, 'topic assignment happens automatically' );
    }

=end programlisting

C<given> also lexicalizes the topic variable to prevent accidental
modification:

=begin programlisting

    given ('mouse')
    {
        say;
        mouse_to_man( $_ );
        say;
    }

    sub mouse_to_man
    {
        $_ = shift;
        s/mouse/man/;
    }

=end programlisting

X<when>

X<topicalization>
X<topicalize>

By itself, this feature may seem less than useful.  In combination with
C<when>, it is very useful.  Use C<given> to I<topicalize> a value.  Within the
associated block, multiple C<when> statements match the topic against
expressions using I<smart-match> semantics.  Thus you might code a Rock, Paper,
Scissors game:

=begin programlisting

    my @options = ( \&rock, \&paper, \&scissors );

    do
    {
        say "Rock, Paper, Scissors!  Pick one: ";
        chomp( my $user = <STDIN> );
        my $computer_match = $options[ rand @options ];
        $computer_match->( lc( $user ) );
    } until (eof);

    sub rock
    {
        print "I chose rock.  ";

        given (shift)
        {
            when (/paper/)    { say 'You win!' };
            when (/rock/)     { say 'We tie!'  };
            when (/scissors/) { say 'I win!'   };
            default           { say "I don't understand your move" };
        }
    }

    sub paper
    {
        print "I chose paper.  ";

        given (shift)
        {
            when (/paper/)    { say 'We tie!'  };
            when (/rock/)     { say 'I win!'   };
            when (/scissors/) { say 'You win!' };
            default           { say "I don't understand your move" };
        }
    }

    sub scissors
    {
        print "I chose scissors.  ";

        given (shift)
        {
            when (/paper/)    { say 'I win!'   };
            when (/rock/)     { say 'You win!' };
            when (/scissors/) { say 'We tie!'  };
            default           { say "I don't understand your move" };
        }
    }

=end programlisting

Perl executes the C<default> rule when none of the other conditions match.

=begin sidebar

The CPAN module C<MooseX::MultiMethods> allows another technique to reduce this
code further.

=end sidebar

The C<when> construct is even more powerful; it can match (L<smart_match>)
against many other types of expressions including scalars, aggregates,
references, arbitrary comparison expressions, and even code references.

=head2 Tailcalls

Z<tailcalls>
X<tailcalls>
X<goto>

A I<tailcall> occurs when the last expression within a function is a call to
another function--the return value of the outer function is the return
value of the inner function:

=begin programlisting

    sub log_and_greet_person
    {
        my $name = shift;
        log( "Greeting $name" );

        return greet_person( $name );
    }

=end programlisting

X<optimization; tailcalls>
X<tailcall optimization>

In this circumstance, returning from C<greet_person()> directly to the caller
of C<log_and_greet_person()> is more efficient than returning to
C<log_and_greet_person()> and immediately returning I<from>
C<log_and_greet_person()>.  Returning directly from C<greet_person()> to the
caller of C<log_and_greet_person()> is an optimization known as I<tailcall
optimization>.

Perl 5 will not detect cases where it could perform this optimization
automatically.

=begin sidebar

Heavily recursive code (L<recursion>), especially mutually recursive code, can
quickly consume a lot of memory.  Using tailcalls reduces the memory needed for
internal bookkeeping of control flow, which can make otherwise expensive
algorithms tractable.

=end sidebar
